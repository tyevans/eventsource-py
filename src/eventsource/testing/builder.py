"""
Event builder for creating test events with minimal boilerplate.

This module provides a fluent builder pattern for constructing domain events
in tests without having to manually specify all required fields.

Example:
    >>> from eventsource.testing import EventBuilder
    >>> from my_app.events import OrderCreated
    >>>
    >>> event = (
    ...     EventBuilder(OrderCreated)
    ...     .with_aggregate_id(order_id)
    ...     .with_field("customer_id", customer_id)
    ...     .build()
    ... )
"""

from datetime import datetime
from typing import Any, Generic, TypeVar
from uuid import UUID, uuid4

from eventsource.events.base import DomainEvent

# Type variable bound to DomainEvent for type-safe builder
TEvent = TypeVar("TEvent", bound=DomainEvent)


class EventBuilder(Generic[TEvent]):
    """
    Fluent builder for creating test events with minimal boilerplate.

    Automatically generates default values for common fields like
    aggregate_id, event_id, and occurred_at, allowing tests to focus
    only on the fields relevant to the test scenario.

    Example:
        >>> event = (
        ...     EventBuilder(OrderCreated)
        ...     .with_aggregate_id(order_id)
        ...     .with_field("customer_id", customer_id)
        ...     .with_field("total", 99.99)
        ...     .build()
        ... )

    Example with multiple fields:
        >>> event = (
        ...     EventBuilder(OrderShipped)
        ...     .with_fields(
        ...         tracking_number="TRACK123",
        ...         carrier="UPS",
        ...     )
        ...     .build()
        ... )

    Auto-generated defaults:
        - aggregate_id: Random UUID
        - event_id: Random UUID
        - aggregate_version: 1
        - occurred_at: Current UTC time

    Note:
        The event class must be a subclass of DomainEvent.
        Validation errors from Pydantic will be raised on build()
        if required fields are missing.

    Type Parameters:
        TEvent: The type of DomainEvent being built
    """

    def __init__(self, event_class: type[TEvent]) -> None:
        """
        Initialize builder for the given event class.

        Args:
            event_class: The DomainEvent subclass to build

        Raises:
            TypeError: If event_class is not a DomainEvent subclass
        """
        if not (isinstance(event_class, type) and issubclass(event_class, DomainEvent)):
            raise TypeError(f"event_class must be a DomainEvent subclass, got {event_class}")

        self._event_class = event_class
        self._fields: dict[str, Any] = {
            "aggregate_id": uuid4(),
            "aggregate_version": 1,
        }

    def with_aggregate_id(self, aggregate_id: UUID) -> "EventBuilder[TEvent]":
        """
        Set the aggregate_id field.

        Args:
            aggregate_id: The aggregate's unique identifier

        Returns:
            Self for method chaining
        """
        self._fields["aggregate_id"] = aggregate_id
        return self

    def with_event_id(self, event_id: UUID) -> "EventBuilder[TEvent]":
        """
        Set the event_id field.

        Args:
            event_id: The event's unique identifier

        Returns:
            Self for method chaining

        Note:
            event_id is auto-generated by default. Use this only when
            you need a specific event_id for test assertions.
        """
        self._fields["event_id"] = event_id
        return self

    def with_tenant_id(self, tenant_id: UUID) -> "EventBuilder[TEvent]":
        """
        Set the tenant_id field for multi-tenant scenarios.

        Args:
            tenant_id: The tenant's unique identifier

        Returns:
            Self for method chaining
        """
        self._fields["tenant_id"] = tenant_id
        return self

    def with_version(self, version: int) -> "EventBuilder[TEvent]":
        """
        Set the aggregate_version field.

        Args:
            version: The aggregate version number

        Returns:
            Self for method chaining
        """
        self._fields["aggregate_version"] = version
        return self

    def with_occurred_at(self, occurred_at: datetime) -> "EventBuilder[TEvent]":
        """
        Set the occurred_at timestamp.

        Args:
            occurred_at: When the event occurred

        Returns:
            Self for method chaining
        """
        self._fields["occurred_at"] = occurred_at
        return self

    def with_correlation_id(self, correlation_id: UUID) -> "EventBuilder[TEvent]":
        """
        Set the correlation_id for event tracking.

        Args:
            correlation_id: The correlation ID linking related events

        Returns:
            Self for method chaining
        """
        self._fields["correlation_id"] = correlation_id
        return self

    def with_causation_id(self, causation_id: UUID) -> "EventBuilder[TEvent]":
        """
        Set the causation_id to link event chains.

        Args:
            causation_id: The ID of the event that caused this event

        Returns:
            Self for method chaining
        """
        self._fields["causation_id"] = causation_id
        return self

    def with_actor_id(self, actor_id: str) -> "EventBuilder[TEvent]":
        """
        Set the actor_id field.

        Args:
            actor_id: The user or system that triggered this event

        Returns:
            Self for method chaining
        """
        self._fields["actor_id"] = actor_id
        return self

    def with_metadata(self, metadata: dict[str, Any]) -> "EventBuilder[TEvent]":
        """
        Set the metadata field.

        Args:
            metadata: Event metadata dictionary

        Returns:
            Self for method chaining

        Example:
            >>> builder.with_metadata({"trace_id": "abc123", "source": "api"})
        """
        self._fields["metadata"] = metadata
        return self

    def with_field(self, name: str, value: Any) -> "EventBuilder[TEvent]":
        """
        Set an arbitrary field by name.

        Args:
            name: The field name
            value: The field value

        Returns:
            Self for method chaining

        Example:
            >>> builder.with_field("customer_id", customer_id)
        """
        self._fields[name] = value
        return self

    def with_fields(self, **kwargs: Any) -> "EventBuilder[TEvent]":
        """
        Set multiple fields at once.

        Args:
            **kwargs: Field names and values

        Returns:
            Self for method chaining

        Example:
            >>> builder.with_fields(customer_id=cid, total=99.99)
        """
        self._fields.update(kwargs)
        return self

    def build(self) -> TEvent:
        """
        Build and return the event instance.

        Returns:
            A validated event instance

        Raises:
            pydantic.ValidationError: If required fields are missing
                or field values are invalid
        """
        return self._event_class(**self._fields)

    def __repr__(self) -> str:
        """Return string representation for debugging."""
        return f"EventBuilder({self._event_class.__name__}, fields={list(self._fields.keys())})"


__all__ = ["EventBuilder", "TEvent"]
